指针和存储区之间的捆绑关系
    可以随着程序的执行而改变
指针可以用来代表存储区的某种特征

如果指针和数组里的第一个存储区捆绑则
    通过这个指针可以找到数组里的每个存储区
在指针后加下标就可以找到数组里的下标对应的存储区

地址数据可以参与如下计算
地址 + 整数     地址 - 整数     地址 - 地址
地址数据加减整数n实际上加减的是n个捆绑存储区大小

数组第一个存储区地址加下标结果是
    下标对应存储区的地址
可以采用如下写法表示数组里下标为num的存储区
    *(arr + num)
地址之间做减法结果是一个整数，这个整数表示两个地址之间包含的
    捆绑存储区个数

声明指针变量的时候可以使用const关键字
可以在声明指针变量的时候把const关键字
    写在类型名称前
程序中不可以通过这种指针对它捆绑的存储区做赋值
    但是可以对指针本身做赋值
    int num = 0;
    const int *p_num = &num;
    *p_num = 10;        //不能给const指针赋值 (编译出错)
    p_num = NULL;       //指针本身可以赋值

可以在声明指针变量的时候把const关键字写在指针变量名称前
可以通过这种指针对它捆绑的存储区做赋值
    但是不可以对这种指针本身做赋值
    int num = 0;
    int * const p_num = &num;
    *p_num = 10;        //可以赋值
    p_num = NULL;       //指针本身不可以赋值 (编译出错)

可以在声明指针的时候使用void作为类型名称
    这种指针叫无类型指针
这种指针可以和任意类型的存储区捆绑
无法通过这种指针知道捆绑存储区的类型
不应该在无类型指针前加*
    也不应该对它做加减整数的计算
这种指针必须首先强制类型转换成有类型指针然后才能使用

所有跨函数使用存储区都是通过指针实现的
数组做形式参数的时候真正的形式参数是一个指针

声明指针形式参数的时候应该尽可能
    在类型名称前使用const关键字
无类型指针通常作为形式参数使用

使用地址作为返回值可以
    调用函数使用被调用函数提供的存储区
这个时候被调用函数需要
    提供一个指针类型的存储区记录作为返回值的地址
不可以把局部变量的地址作为返回值使用



C语言中所有文字信息必须记录
    在一组连续的字符类型存储区里
所有文字信息必须以'\0'字符作为结尾
    这个字符的ASCII码就是0
符合以上两个特征的内容叫字符串
    它们可以用来表示文字信息
字符串里'\0'字符前面的内容是有效文字信息
所有字符串都可以使用一个字符类型指针表示

字符串字面值是一种字符串，用两个双引号中间的一组字符表示
    "Lizard","Admin","Root"
编译器在编译的时候会自动在字符串字面值的末尾加上'\0'字符
编译器会把字符串字面值替换成第一个字符所在存储区的地址
字符串字面值的内容在程序执行过程中不可以改变
程序中如果有多个内容一样的字符串字面值则它们其实是同一个
编译器会把多个并列的字符串字面值合并成一个

字符数组也可以用来表示字符串
只有包含'\0'字符的字符数组才可以当作字符串使用
可以采用字符串字面值会字符数组进行初始化
    这个时候计算机会把字符串字面值末尾的
    '\0'字符也初始化到字符数组里
字符数组里的字符串内容可以修改

可以在printf()函数调用语句里
    使用%s作为占位符把字符串内容显示在屏幕上

    预习:
        1.字符串
        2.预处理指令
